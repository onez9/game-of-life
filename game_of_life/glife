#!/usr/bin/python3

import numpy as np
from time import sleep
import os







clear = lambda: os.system('clear')









if __name__=='__main__':
    a = np.zeros((10, 2))

    print('Исходная матрица: ')
    print(a)

    print('Транспонированная матрица: ')
    b = a.T 
    print(b)
    del b
    #print(np.array([3, '345]))

#  просто меняет форму 
    print(a.view())
    print(a.view())

# новая матрица
    print('новая матрица:')

# Заполняет массив от 0 до n
    b = np.arange(8)
    print(b)

# печатает все переменные
    print('start dir(): ', *dir(), sep='\n', end='\nend dir()\n')
    print('start globals(): ', *globals(), sep='\n', end='\nend globals()\n')

# создаёт новый массив с изменённой формой, но теми же элементами
    print(b.reshape(4, 2))

# с-like
    print(np.reshape(b, (2, 4)))

# Fortra-like
    print(np.reshape(b, (2, 4), order='F'))
    print(np.reshape(b, (4, -1)))


# умножение матриц
# случайные целые числа
    test_matrix = np.random.randint(low=0, high=100, size=(20, 20))
# случайные не целые числа
    #test_matrix = np.random.uniform(low=0, high=100, size=(20, 20))
    #test_matrix = np.a
    #test_matrix = np.mgrid[-5:5.1:0.5, -5:5.1:0.5]

    print(test_matrix)

    #test_matrix = np.array([[1,32,3], [24, 45, 45], [7,48,9]])
    print(type(test_matrix))

    res_det = np.linalg.det(test_matrix)
    print(res_det)

    speed = 0.2
    rows=36
    cols=36

    mapc = np.zeros(dtype=int, shape=(rows, cols))
    mapd = mapc.copy()
    mape=[['.']*cols for i in range(rows)]

    #mapc[18][18]=1

    ## cеверо-запад
    #offset2x=20
    #offset2y=25
    #mapc[(0+offset2y)%rows][(cols-3+offset2x)%cols] = 1
    #mapc[(0+offset2y)%rows][(cols-2+offset2x)%cols] = 1
    #mapc[(0+offset2y)%rows][(cols-1+offset2x)%cols] = 1
    #mapc[(1+offset2y)%rows][(cols-3+offset2x)%cols] = 1
    #mapc[(2+offset2y)%rows][(cols-2+offset2x)%cols] = 1

    ## северо-восток
    #offset1x=0
    #offset1y=16
    #mapc[(0+offset1y)%rows][(0+offset1x)%cols] = 1
    #mapc[(0+offset1y)%rows][(1+offset1x)%cols] = 1
    #mapc[(0+offset1y)%rows][(2+offset1x)%cols] = 1
    #mapc[(1+offset1y)%rows][(2+offset1x)%cols] = 1
    #mapc[(2+offset1y)%rows][(1+offset1x)%cols] = 1

    ## юго-запад
    #offsetx=25
    #offsety=0
    #mapc[(0+offsety)%rows][(1+offsetx)%cols] = 1
    #mapc[(1+offsety)%rows][(0+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(2+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(1+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(0+offsetx)%cols] = 1

    ## юго-восток
    #offsetx=0
    #offsety=0
    #mapc[(0+offsety)%rows][(1+offsetx)%cols] = 1
    #mapc[(1+offsety)%rows][(2+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(2+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(1+offsetx)%cols] = 1
    #mapc[(2+offsety)%rows][(0+offsetx)%cols] = 1

    mapc[15][17]=1
    mapc[16][17]=1
    mapc[17][17]=1
    mapc[18][17]=1
    mapc[19][17]=1
    mapc[20][17]=1
    mapc[21][17]=1
    mapc[22][17]=1
    mapc[23][17]=1
    mapc[24][17]=1

    #print(mapc.size)
    #length=mapc[0].size
    count=0
    try:
        while True:
            for i in range(0, rows):
                for j in range(0, cols):
                    if i==0 and j==0:
                        number_neighbour_cell=mapc[rows-1][cols-1]+mapc[rows-1][j]+mapc[rows-1][j+1]+mapc[i][rows-1]+mapc[i][j+1]+mapc[i+1][cols-1]+mapc[i+1][j]+mapc[i+1][j+1]
                    elif i==rows-1 and j==cols-1:
                        number_neighbour_cell=mapc[i-1][j-1]+mapc[i-1][j]+mapc[i-1][0]+mapc[i][j-1]+mapc[i][0]+mapc[0][j-1]+mapc[0][j]+mapc[0][0]
                    elif i==rows-1 and j==0:
                        number_neighbour_cell=mapc[i-1][cols-1]+mapc[i-1][j]+mapc[i-1][j+1]+mapc[i][cols-1]+mapc[i][j+1]+mapc[0][cols-1]+mapc[0][j]+mapc[0][j+1]
                    elif i==0 and j==cols-1:
                        number_neighbour_cell=mapc[rows-1][j-1]+mapc[rows-1][j]+mapc[rows-1][0]+mapc[i][j-1]+mapc[i][0]+mapc[i+1][j-1]+mapc[i+1][j]+mapc[i+1][0]
                    elif i==0:
                        number_neighbour_cell=mapc[rows-1][j-1]+mapc[rows-1][j]+mapc[rows-1][j+1]+mapc[i][j-1]+mapc[i][j+1]+mapc[i+1][j-1]+mapc[i+1][j]+mapc[i+1][j+1]
                    elif i==rows-1:
                        number_neighbour_cell=mapc[i-1][j-1]+mapc[i-1][j]+mapc[i-1][j+1]+mapc[i][j-1]+mapc[i][j+1]+mapc[0][j-1]+mapc[0][j]+mapc[0][j+1]
                    elif j==0:
                        number_neighbour_cell=mapc[i-1][cols-1]+mapc[i-1][j]+mapc[i-1][j+1]+mapc[i][cols-1]+mapc[i][j+1]+mapc[i+1][cols-1]+mapc[i+1][j]+mapc[i+1][j+1]
                    elif j==cols-1:
                        number_neighbour_cell=mapc[i-1][j-1]+mapc[i-1][j]+mapc[i-1][0]+mapc[i][j-1]+mapc[i][0]+mapc[i+1][j-1]+mapc[i+1][j]+mapc[i+1][0]
                    else:
                        number_neighbour_cell=mapc[i-1][j-1]+mapc[i-1][j]+mapc[i-1][j+1]+mapc[i][j-1]+mapc[i][j+1]+mapc[i+1][j-1]+mapc[i+1][j]+mapc[i+1][j+1]

                    if number_neighbour_cell==3:
                        mapd[i][j]=1
                        mape[i][j]='*'
                    elif number_neighbour_cell==2:
                        mapd[i][j]=mapc[i][j]
                        mape[i][j]='*' if mapd[i][j]==1 else '.'
                    else:
                        mapd[i][j]=0
                        mape[i][j]='.'


            count+=1
            clear()
            mapc = mapd.copy()
            #print(mapc)
            for item in mape:
                print(*item, sep=' ', end='\n')
            print(f'Стадия: {count}')

            sleep(speed)
    
    except KeyboardInterrupt:
        print('Выход')


